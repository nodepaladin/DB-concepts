### **数据库事务的ACID特性**
> ### Atomicity 原子性
事务的一系列数据库操作要么都完成，要么都不完成。
MySQL的原子性是通过undo log和redo log实现的，undo log会记录每条操作的反操作，回滚的时候执行undo log记录的操作命令即可。
> ### Consistency 一致性
事务操作前后，数据库从一个一致状态变到另一个一致状态。
> ### Isolation 隔离性
多个事务之间相互隔离。有多种隔离级别
如果不考虑事务的隔离性可能产生的几种数据错误的情况：  
1. 脏读  
一个事务中读取了另一个未提交的事务中的数据。比如事务A执行转账操作将100元由用户a转到用户b，A执行完a-100后a用户的余额被事务B读取，而后
事务A进行了回滚。此时事务B读取到a的数据就是脏数据，即实际上错误的数据。
2. 重复读
一个事务范围内重复读了被另一个事务提交前后修改的数据。比如事务A读取变量a的值，这个时候事务B立马修改了变量a，事务A再次读取a的时候a变成了另外一个值，重复读到了不同的a的值。
3. 幻读  
一个事务A对数据进行了批量更改，另一个事务B又新增了一条数据，新增数据对应的更改值还是原始值，因此事务A读到的数据中有一条数据对应的值并没有符合预期，就好像没有更改成功一样，称为幻读。  
```
脏读是因为读取了实际上没有提交的事务的部分操作后的数据；
重复读是重复读取了另一个事务提交前后的同一个值；
而幻读是读取到了一个被另一个事务新增数据的值；
```
* #### Serializable （串行化） 
可避免脏读、重复读、幻读
* #### Repeatable Read （重复读）
可避免脏读、重复读。MySQL默认事务隔离级别
* #### Read commited （已提交）
可避免脏读
* #### Read unCommited （未提交）
啥都避免不了
> ### Durability 持久性
事务对数据库数据造成的影响是持久性的。
### 数据库锁机制
> #### 排它锁（Exclusive Lock）  
当数据对象被加上排它锁后，其他的事务不能对这个数据对象进行读取和修改
> #### 共享锁（Share Lock）  
当数据被加上共享锁后，其他的事务可以对这个数据对象进行读取但不能修改

### 数据库死锁
> 1.事务A读取表A，锁定表A，同时又读取表B，事务B读取表B，同时又读取表A，这个时候由于表A被锁定，所以只能等表A被释放，而事务A读取表B因为B被锁定所以事务A永远无法完成，造成死锁。  
>> 这种死锁是因为程序设计逻辑的问题，改变程序的实现逻辑即可解决。   
